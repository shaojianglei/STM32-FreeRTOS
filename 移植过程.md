#  前期准备

开发板（我用的是正点原子STM32F103ZET6）

FreeRTOS源码:(两种方式，第一种从FreeRTOS官网获取源码https://www.freertos.org/

第二种从代码托管网站下载:[FreeRTOS Real Time Kernel (RTOS) download | SourceForge.net](https://sourceforge.net/projects/freertos/))

Keil5

# 源码移植

## 建立Keil文件夹

![img](https://i-blog.csdnimg.cn/direct/6a8314a0ee5a4f71811b29f4fd851c6e.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

如图所示，红圈部分为建立的新的文件夹，Src用于存放基本的task.c和timer,c文件，port文件夹存放内存管理文件。

我的工程目录如下:

![img](https://i-blog.csdnimg.cn/direct/806e2f4fac774600920fb8f1cc1d0563.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

![img](https://i-blog.csdnimg.cn/direct/1d0d446b78a94cecaa6a362dd2fa74dd.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

其中的的include文件夹是直接复制源码文件

所在位置如下（在已解压的源码文件中）

![img](https://i-blog.csdnimg.cn/direct/0a44a661f29d429bad8e49aa606a1776.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

![img](https://i-blog.csdnimg.cn/direct/77402097baf9459cbce9929fa7134577.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

![img](https://i-blog.csdnimg.cn/direct/851c256c32ca4c41a6782ba0f728e60b.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

将这个include文件夹直接复制到工程建立的FreeRTOS文件夹下

至此文件夹建立部分已经完成

## 移植源码

### Src文件夹

Src文件夹下主要是task等基础文件，所在路径为

path to kernel\FreeRTOSv202411.00\FreeRTOSv202411.00\FreeRTOS\Source

不同版本源码可能有区别，但是找选中的这几个文件就可以

![img](https://i-blog.csdnimg.cn/direct/0d0327a1230f4bc58bf687fdac67128a.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

将这些添加到Src文件夹下即可

### Port文件夹

port文件夹主要是内存管理以及port文件

路径如下

![img](https://i-blog.csdnimg.cn/direct/d21959a6db4f4d158446c3f73a5f7d13.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

我的是Keil工程，直接将这两个文件夹复制到自己建立的port文件夹中即可

![img](https://i-blog.csdnimg.cn/direct/302dc40b86ce43418f702224cc3e6296.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑



## 向keil中添加文件

Src文件夹直接添加移植好的六个文件即可

![img](https://i-blog.csdnimg.cn/direct/c8382d4865214494b061588b382e8751.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

Port文件夹中添加MemMang中的heap4.c

![img](https://i-blog.csdnimg.cn/direct/21f501aff45d4906b5be1d4e2bec3739.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

![img](https://i-blog.csdnimg.cn/direct/a5371f981f174d2982ca59b66fc4ff9f.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

此外还要添加适宜内核版本的port.c文件，这个文件位于之前复制的RVDS文件夹中

（这一步注意要选择合适版本的内核，我的F1是M3内核）

![img](https://i-blog.csdnimg.cn/direct/268bf8ce201b43e78f6bdda16ec4bf7f.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

![img](https://i-blog.csdnimg.cn/direct/eff2bd8d4d914e7998e38c389df97357.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

![img](https://i-blog.csdnimg.cn/direct/42013ad4cb8747f2921eda56330ff8ff.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑



下一步是移植相应的FreeRTOSConfig.h文件，这个文件可以从官方源码的Demo中找到自己的单片机类型的例程中复制下来

![img](https://i-blog.csdnimg.cn/direct/245c6828ac7e41a5a9a1734b89a3982e.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

![img](https://i-blog.csdnimg.cn/direct/82c264670b614ec9bda841eb7b3edf33.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

![img](https://i-blog.csdnimg.cn/direct/2947210469b043c18d37a21e193772b3.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

我把它直接放在main的文件夹中

![img](https://i-blog.csdnimg.cn/direct/31684fbbc08c47a3bdd28e1e0c285c5c.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑



### 添加头文件路径！！

这一步千万别忘记

![img](https://i-blog.csdnimg.cn/direct/188ccb73b1774338ac05037b35159008.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑



## 修改源码

首先修改stm32f1xx_it.c文件内容

注释掉PendSV和SVC两个中断处理函数，因为这两个函数FreeRTOS已经帮我们写过了，不注释会出现重复定义问题

![img](https://i-blog.csdnimg.cn/direct/c32e6c73c7eb461da7ee640ca6ee1b23.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

![img](https://i-blog.csdnimg.cn/direct/b76774818bf24f5b83cbec9b3a173f38.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑



注释掉后，还要在portmicro.h中补充两个宏定义（这个文件是port.c依赖的头文件）

![img](https://i-blog.csdnimg.cn/direct/298ae98151af47d59f6a88d02ac6d447.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

```cpp
#define vPortSVCHandler SVC_Handler
#define xPortPendSVHandler PendSV_Handler
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

接下来是修改时钟中断函数

![img](https://i-blog.csdnimg.cn/direct/3c6bb6d2d3224635918ab7becbbe8c1d.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

```cpp
/**
  * @brief This function handles System tick timer.
  */
extern void xPortSysTickHandler( void );
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */
	#if (INCLUDE_xTaskGetSchedulerState  == 1 )
      if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
      {
    #endif  /* INCLUDE_xTaskGetSchedulerState */  
        xPortSysTickHandler();
    #if (INCLUDE_xTaskGetSchedulerState  == 1 )
      }
    #endif  /* INCLUDE_xTaskGetSchedulerState */
  /* USER CODE END SysTick_IRQn 0 */

  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

接下来就是在main.c函数中创建示例代码

```cpp
//上面是自带的头文件
/* USER CODE BEGIN Includes */
#include "lcd.h"
#include "FreeRTOS.h"
#include "task.h"
/* USER CODE END Includes */
/* USER CODE BEGIN PM */
static void AppTaskCreate(void);
 
 
static TaskHandle_t AppTask_Handle = NULL;//任务句柄
/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
void delay_ms(uint32_t ms)//自己实现的延时函数，可忽略
{
    uint32_t ms_uwTick=uwTick;
    while (uwTick - ms_uwTick < ms)
    {
       
    }
}
static void AppTask(void* parameter);//任务函数
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  /* USER CODE BEGIN 2 */
	BaseType_t xReturn = pdPASS;
	lcd_init();
	lcd_clear(WHITE);
	lcd_show_string(30,30,240,30,24,"Hello world",RED);//上面三行是我的lcd测试代码可忽略
	xReturn = xTaskCreate((TaskFunction_t )AppTask,  //创建任务函数，具体参数可见freertos官网
                        (const char*    )"AppTask",
                        (uint16_t       )512,  
                        (void*          )NULL,
                        (UBaseType_t    )1, 
                        (TaskHandle_t*  )&AppTask_Handle);*/ 
            
  if(pdPASS == xReturn)//检查任务是否调用
    vTaskStartScheduler();  
  else
    return -1;
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
		
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

//下面是任务函数的实现
static void AppTask(void* parameter)
{	
    while (1)
    {
        HAL_GPIO_WritePin(GPIOB,GPIO_PIN_5,GPIO_PIN_SET);
        vTaskDelay(500);   
        HAL_GPIO_WritePin(GPIOB,GPIO_PIN_5,GPIO_PIN_RESET);    
        vTaskDelay(500);  	 		
    }
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

到这里基本就移植完成了，本文章只是记录过程，具体其中的原理讲解可以看这两篇文章

[超详细的FreeRTOS移植全教程——基于stm32_freertos移植教程-CSDN博客](https://blog.csdn.net/ba_wang_mao/article/details/127628185)

[超详细的FreeRTOS移植全教程——基于srm32 - 杰杰IoT - 博客园](https://www.cnblogs.com/iot-dev/p/11681067.html)

不过这两篇文章都缺少了上面提到的添加这两个宏定义的步骤，所以导致我一开始始终不成功，要注意